<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>fast-persistent-queue by btoddb</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>fast-persistent-queue</h1>
        <h2>A mostly FIFO fast persistent queue</h2>

        <section id="downloads">
          <a href="https://github.com/btoddb/fast-persistent-queue/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/btoddb/fast-persistent-queue/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/btoddb/fast-persistent-queue" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
          <h3>Latest Maven Site Build</h3>
          <p/><a href="0.0.14/index.html">0.0.14</a>

<h3>What is It?</h3>

<p/>
  fast-persistent-queue (FPQ) is an attempt to make a mostly FIFO, durable, fault-tolerant, deliver-at-least-once queue.
  If your needs are for a strictly FIFO queue, then this isn't the one for you (at least not at the moment).
  If all is going well, all events are written to an append only log file for durability and only pushed/popped in-memory.
<p/>
  The memory management is setup in segments and are paged in/out from disk - totally separate from the log file.  When the
  threshold for memory usage is exceeded, the newest *complete* segment will be paged to disk, leaving the newest *incomplete*
  segment for pushing, and some of the oldest segments for "popping".
<p/>  
  When popping from the queue, the next event from the oldest segment is returned, which gives us FIFO.  However, if the
  needed segment is paged to disk the pop will use the next segment that *is* in memory - skipping some events, which breaks
  FIFO.  As soon as the segment is in memory and ready, the next pop will return from the "just loaded" segment.  This is
  why the queue is *mostly* FIFO.
<p/>
  The downside is that disk space is not considered important and will basically be doubled if the queue starts backing up.
  One copy of the data in the log files and the other in the segment page files.  A premium is put on speed and therefore
  even when the queue is backing up, it is operating very fast since pops always come from memory, never (or very seldom)
  waiting on disk I/O.
  
  
      </section>
    </div>

    
  </body>
</html>
